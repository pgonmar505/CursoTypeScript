{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,uDAAuD;AACvD;AACA;AACA;AACA,0MAA0M,cAAc;AACxN,8BAA8B,sBAAsB;AACpD,0BAA0B,YAAY,sBAAsB,qCAAqC,2CAA2C,MAAM;AAClJ,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA,2BAA2B,QAAQ,KAAK,MAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe,sBAAsB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kBAAkB,4BAA4B,kBAAkB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,+BAA+B,aAAa;AAC5C;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA,yCAAyC,eAAe,MAAM,cAAc;AAC5E;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe,KAAK,cAAc;AAC3E,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B,cAAc,iBAAiB,cAAc,sBAAsB,iBAAiB;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB,gDAAgD;AACzE;AACA,mBAAmB,+CAA+C;AAClE;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO,EAAE,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,aAAa,OAAO,eAAe,YAAY,IAAI,oBAAoB,MAAM,oCAAoC,MAAM,OAAO;AAClK,oCAAoC,aAAa,OAAO,eAAe,YAAY,IAAI,mBAAmB,MAAM,oCAAoC,MAAM,OAAO;AACjK;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,gDAAgD;AAChD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA,wBAAwB;AACxB,2BAA2B;;;;;;;;UE3a3B;UACA;UACA;UACA;UACA","sources":["webpack://cursotypescript/./src/index.ts","webpack://cursotypescript/webpack/before-startup","webpack://cursotypescript/webpack/startup","webpack://cursotypescript/webpack/after-startup"],"sourcesContent":["\"use strict\";\n// Sintasis básica de TypeScript\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n/**\n * En este archivo iremos añadiendo líneas de código\n * con la sintaxis básica de TypeScript para que nos\n * sirva de guia y nos ayude en el futuro.\n */\n// 1. Imprimir por consola\n// En TypeScript no es necesario acabar las líneas con ;\nconsole.log(\"Hola Mundo\");\n/**\n * 2. Tipos de Variables\n *\n * var - variable global\n * let - variable local\n * const - constante\n*/\nvar nombre = \"Jose\"; // Variable global\nlet email = \"jose@gmail.com\";\nconst PI = \"3.141592\";\n//Formas de concatenar variables y texto\nconsole.log(\"Hola \" + nombre);\nconsole.log(`¿Cuál es tu apellido ${nombre}`);\nconsole.log(\"Que tengas un buen día\", nombre);\nconsole.log(`El email de ${nombre} es ${email}`);\n/**\n * 3. Tipos de datos\n * En TypeScrip es muy recomendable indicar el tipo de dato\n * que almacenará cada una de las variables y constantes.\n *\n *  - string\n *  - number: incluye tanto enteros como decimales\n *  - boolean\n *  - null\n *  - undefined: variable cuyo valor no haya sido especificado.\n *  - any: el valor de la variable puede ser de cualquier tipo\n */\nvar apellido1 = \"Jose\";\nvar edad = 18;\nvar esMayorDeEdad = true;\nvar curso; // Al no indicar ningún tipo TypeScript le asigna any\n// Instanciación de múltiples variables;\nlet a, b, c;\na = \"A\";\nb = true;\nc = 2.5;\n// Array de datos\nlet listaTareas = [\"Tarea 1\", \" Tarea 2\", \" Tarea 3\"];\nlet valores = [3, 2.4, true, \"ABC\"];\n// Concatenación de arrays mediante factor de propagación\nlet nuevaListaTareas = [...listaTareas, \"Tarea 4\"];\nconsole.log(nuevaListaTareas);\n/***\n * Creación de un objeto compuesto por datos primitivos\n */\nlet misDatos = {\n    nombre: \"Jose Antonio\",\n    apellido: \"Rodriguez\",\n    edad: 18\n};\nObject.keys('');\n//Propagación de la variable misDatos\nlet misDatoProfesionales = Object.assign(Object.assign({}, misDatos), { profesion: \"Docente\" });\n// Declaración y Asignación 1 a 1\nlet miNombre = misDatos.nombre;\nlet miApellido = misDatos.apellido;\nlet miEdad = misDatos.edad;\n/**\n * Enumerados : permite definir un conjunto de constantes bajo un identificador.\n * Si imprimimos el valor de un valor del enumerado observaremos que\n * lo que almacena es el un valor numérico.\n *\n *  */\nvar EstadoTarea;\n(function (EstadoTarea) {\n    EstadoTarea[EstadoTarea[\"Pendiente\"] = 0] = \"Pendiente\";\n    EstadoTarea[EstadoTarea[\"EnProceso\"] = 1] = \"EnProceso\";\n    EstadoTarea[EstadoTarea[\"Completada\"] = 2] = \"Completada\";\n})(EstadoTarea || (EstadoTarea = {}));\n;\nlet estado = EstadoTarea.Pendiente;\nconsole.log(`El valor del enumerado Pendiente es: ${estado}`);\n/**\n * El enumerado está actuando como una tupla Key:Value.\n * Por defecto la primera key es == a 0. Podemos también cambiar esto.\n * Podemos establecer una clave para cada valor del enumerado:\n *  */\n// enum EstadoTarea { \"Pendiente\" =\"P\", \"EnProceso\" =\"E\", \"Completada\"=\"C\"};\nvar PosicionCarrera;\n(function (PosicionCarrera) {\n    PosicionCarrera[PosicionCarrera[\"Primero\"] = 1] = \"Primero\";\n    PosicionCarrera[PosicionCarrera[\"Segundo\"] = 2] = \"Segundo\";\n    PosicionCarrera[PosicionCarrera[\"Tercero\"] = 3] = \"Tercero\";\n})(PosicionCarrera || (PosicionCarrera = {}));\n;\nconsole.log(`Has quedado en la posición ${PosicionCarrera.Primero}`);\nlet tarea1 = {\n    nombre: \"Tarea1\",\n    estado: EstadoTarea.Pendiente,\n    prioridad: 1\n};\nconsole.log(tarea1);\nconsole.log(tarea1.nombre);\nlet empleado1 = { nombre: \"Juan\", salario: 1500 };\n/* Intersección de datos: permite combinar dos o más tipos de datos en uno solo.\n*/\nlet empleado2;\nempleado2 = { isAdmin: true, nombre: \"Jose\", salario: 2000 };\n/**\n * Estructuras de control: operador ternario, if, switch\n * Operador Ternario\n * condición ? expr1 : expr2\n * Si la condición es true, el operador retorna el valor de la expr1;\n *  de lo contrario, devuelve el valor de expr2.\n */\nconsole.log(empleado1.salario > 1500 ? `El empleado ${empleado1.nombre} es Senior` : `El empleado ${empleado1.nombre} es Junior`);\n/***\n * Operadores de comparación:\n *\n * == -> compara el valor de la variable\n * === compara el valor de la variable + el tipo de datos\n */\nlet tarea3 = { estado: EstadoTarea.EnProceso, nombre: \"Tarea3\", prioridad: 3 };\n// Estructura if-else: if (){} else if (){} else{}\nif (tarea3.estado == EstadoTarea.EnProceso && tarea3.prioridad === 1) {\n    console.log(`La tarea ${tarea3.nombre} es de máxima prioridad`);\n}\nelse if (tarea3.estado == EstadoTarea.Pendiente) {\n    console.log(`La tarea ${tarea3.nombre} aún no ha comenzado`);\n}\nelse {\n    console.log(`El estado de la tarea ${tarea3.nombre} es  ${tarea3.estado}`);\n}\n// Estructura Switch: switch (valor){case: break; default: break;}\nswitch (tarea3.estado) {\n    case EstadoTarea.Completada:\n        console.log(\"Tarea completada\");\n        break;\n    case EstadoTarea.EnProceso:\n        console.log(\"Tarea en proceso\");\n        break;\n    default:\n        console.log(\"Tarea pendiente\");\n        break;\n}\n// Estructura Try - Catch : para capturar errores\ntry {\n    let numero = 3.14;\n    console.log(numero.toString());\n}\ncatch (error) {\n    console.log(\"Se ha producido el siguiente error\", error);\n}\n/**\n * Estructura de repetición - Bucles :\n */\nlet tarea2 = { estado: EstadoTarea.Completada, nombre: \"Tarea 2\", prioridad: 0 };\nlet listadoTareas = [tarea1, tarea2, tarea3];\n//FOREACH\nlistadoTareas.forEach((elemento, indice, arreglo) => {\n    console.log(indice, elemento.nombre, arreglo[indice].estado);\n});\n/**\n * FOR\n * Cuando trabajamos con tipos de datos no funciona\n * for (const tarea: Tarea in listadoTareas){}\n */\n// FOR CLÁSICO\nfor (let index = 0; index < listaTareas.length; index++) {\n    const tarea = listaTareas[index];\n    console.log(tarea);\n}\n// WHILE\nwhile (tarea1.estado != EstadoTarea.Completada) {\n    console.log(\"Tarea no completada\");\n    tarea1.estado = EstadoTarea.Completada;\n}\ndo {\n    console.log(`El estado de la tarea ${tarea1.nombre} es ${tarea1.estado}`);\n} while (tarea1.estado != EstadoTarea.Completada);\n/**\n * Funciones: nos permitirá crear bloque de códigos reutilizables.\n *\n * funtion name (nameParam: type): Type return{}\n *\n */\n// Funciónes clásicas y documentación del código\n/**\n * Muestra un saludo por consola a una persona\n * @param nombre string nombre del usuario\n *\n */\nfunction saludar(nombre) {\n    console.log(`Hola ${nombre}, qué tal estas?`);\n}\nsaludar(\"José Antonio\");\n//Funciones con parámeros por defecto\nfunction saludarDefault(nombre = \"Jose\") {\n    console.log(`Hola ${nombre}, qué tal estas?`);\n}\nsaludarDefault();\nsaludarDefault(\"Juan\");\n//Funciones con parámeros opcionales\nfunction saludarOpcional(nombre) {\n    let nombreParam = nombre;\n    if (nombreParam == undefined) {\n        nombreParam = \"Nombre Defecto\";\n    }\n    console.log(`Hola ${nombreParam}, qué tal estas?`);\n}\nsaludarOpcional();\n// Funciones con parámetros de varios tipos\nfunction variosTipos(a) {\n    if (typeof (a) == \"string\") {\n        console.log(\"a es un string\");\n    }\n    else {\n        console.log(\"a es un number\");\n    }\n}\nvariosTipos(1);\n// Función con retorno: return\nfunction suma(a, b) {\n    return a + b;\n}\n// Podemos almacenar directamente el valor devuelto de la función en una variable\nvar resultadoSuma = suma(1, 2);\nconsole.log(resultadoSuma);\nconsole.log(suma(1, 2));\n// Funciones anónimas: no se especifica un nombre.\n/**\n * Suma dos valores\n * @param valor1 primer valor\n * @param valor2 segundo valor\n * @returns devuelve la suma de valor1 y valor2\n */\nconst funcRestar = function (valor1, valor2) {\n    return valor1 - valor2;\n};\n/**\n * Funciones, rest parameters (parámetros rest)\n * Permite definir funciones que tomen un número indeterminado de argumentos\n */\nfunction multiParam(...nombres) {\n    nombres.forEach((nombre) => {\n        console.log(nombre);\n    });\n}\n// Llamada a función multiparámetros\nmultiParam(\"Alex\", \"Martin\");\n// A las funciones rest también se le puede pasar una lista de elementos\nlet listaNombres = [\"Leandro\", \"Francisco\"];\nmultiParam(...listaNombres);\n/**\n * La diferencia entre usar una función que reciba como parámetro un array es que esta función recibe como parámetro una referencia al objeto.\n * En cambio, con una función rest param lo que recibe como parámetro es cada uno de los elementos de la lista de forma individual.\n*/\n/**\n * Las funciones arrow son una sintaxis compacta de definir funciones en JavaScript y TypeScript.\n * Proporcionan una forma más breve y clara de escribir funciones en comparación con la sintaxis tradicional,\n * lo que mejora la legibilidad y mantiene la seguridad de los tipos.\n *\n * (param1, param2, ..., paramN): Type return => {}\n */\nlet getDatosTarea = (tarea) => { return `La tarea denominada ${tarea.nombre} cuyo estado es ${tarea.estado} tiene una prioridad ${tarea.prioridad} `; };\nconsole.log(getDatosTarea(tarea1));\n/**\n * Funciones CallBack\n * Una función callback es una función que se pasa a otra función como parámetro y dentro de la misma es llamada.\n * Hay que tener en cuenta que una función se trata como un objeto.\n */\n//Ejemplo 1: \nconst funcionMuestra = function () {\n    console.log(\"CallBack desde función estándar\");\n};\nsetTimeout(funcionMuestra, 100); // La función timeout llama a funciónMuestra después de 100ms\n// Ejemplo 2: paso de una función anónima\nsetTimeout(function () { console.log(\"CallBack desde función anónima\"); }, 1000);\n// Ejemplo 3: paso de una función flecha\nsetTimeout(() => { console.log(\"CallBack desde función flecha\"); }, 500);\n// Ejemplo 4:\nlet muestraDatos = function (a, b, c) {\n    console.log(`Ejemplo 4 - ${a}`);\n};\nlistaTareas.forEach(muestraDatos);\nlistaTareas.forEach((valor, indice, datos) => {\n    console.log(`${valor}, mostrado desde función CallBack fecha`);\n});\n// Ejemplo 5: \nlet fsuma = function suma(a, b) {\n    return a + b;\n};\nlet fresta = function resta(a, b) {\n    return a - b;\n};\n// En este ejemplo estamos definiendo que la función opera espera recibir como parámetro una función CallBack\n// Concretamente, estamos diciendo que la función como entrada tiene que tener dos parámetros y devolver un número\n// Cuando se llama a dicha función CallBack desde la función principal se le pasan dichos parámetros y se vuelve a operar con el resultado\nfunction opera(x, y, callbackfuntion) {\n    return callbackfuntion(x, y);\n}\nopera(2, 3, fsuma);\nopera(2, 3, fresta);\n/**\n * Funciones asíncronas:\n *\n * Toda función asíncrona debe devolver una promesa. ¿Qué es una promesa?\n * Una promesa es una espectativa que sucederá en algún momento particular del futuro.\n */\n/**\n * En el siguiente ejemplo vamos a usar una función asíncrona para acceder a una API desde la que vamos a obtener un JSON.\n * A continuación se indican algunas API públicas que se pueden consultar.\n *\n * https://www.postman.com/cs-demo/public-rest-apis/folder/c89mnom/television\n * http://universities.hipolabs.com/search?country=spain\n * https://dog.ceo/api/breeds/image/random\n */\n/**\n * Funcion asíncrona que consulta una API que contiene un directorio de universidades de todo el mundo.\n * @param pais pais sobre el que se quiere filtrar los resultados\n * @returns devuelve un JSON.\n */\nfunction getUniversitiesAsync(pais) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let index = 0;\n        const apiURL = \"http://universities.hipolabs.com/search?country=\";\n        //Construimos la URL de la API a consultar concatenando el pais que se quiere filtrar\n        let url = `${apiURL}${pais}`;\n        // Con la función fetch accedemos hacemos una petición GET y obtenemos los resultados. \n        // Usamos await para indicar que hasta que no termine esta instrucción no se ejecuta la siguiente\n        let respuesta = yield fetch(url);\n        // Convertimos la respuesta de la petición GET en un archivo JSON\n        let datos = yield respuesta.json();\n        return datos;\n    });\n}\n// Llamamos a la función asincrona y mostramos el JSON de las universidades existentes en Spain\ngetUniversitiesAsync(\"Spain\").then((data) => { console.log(data[1]); });\n// Como curiosidad, podéis observar que esta línea se ejecuta antes aún estando después de la llamada a la API. \n// Esto ocurre porque la función getDataFromAPI es una función asíncrona y muestra los resultados en el momento que termina su ejecución.\nconsole.log(\"Linea posterior a funcion async\");\n/**\n * FUNCIONES GENERADORAS:\n * Una función generadora es una función que se puede pausar y reanudar, y por lo tanto, nos puede devolver múltiples valores.\n * Para poder declarar una función generadora es necesario añadir el * después de la palabra reservada function.\n * Observa que en lugar de llamar a return para devolver un valor, utilizamos yield.\n * Fuente:https://lenguajejs.com/javascript/funciones/generadores/\n */\n// Ejemplo 1: Función que itera elementos de un array y los devuelve\nfunction* fGenTareas() {\n    let tareas = [...listadoTareas];\n    for (let i in tareas) {\n        yield tareas[i];\n    }\n    // No es posible usar la función foreach porque al ser una función callback no se puede usar con yield.\n}\n// Preparamos nuestra función generadora\nconst genTareas = fGenTareas();\nconsole.log(genTareas.next()); // Accedemos al primer valor del array\nfunction generatorGetBreaches() {\n    return __asyncGenerator(this, arguments, function* generatorGetBreaches_1() {\n        let respuesta = yield __await(fetch(\"https://haveibeenpwned.com/api/v2/breaches\"));\n        // Convertimos la respuesta de la petición GET en un archivo JSON\n        let datos = yield __await(respuesta.json());\n        for (let i in datos) {\n            yield yield __await(datos[i]);\n        }\n    });\n}\nconst valoresUniversidades = generatorGetBreaches();\nvaloresUniversidades.next().then(({ value, done }) => { console.log(`${value.Name} - ${value.Description}  \\n`); console.log(`Is the last element? ${done} \\n`); });\nvaloresUniversidades.next().then(({ value, done }) => { console.log(`${value.Name} - ${value.Description} \\n`); console.log(`Is the last element? ${done} \\n`); });\n// Implementación de la función\nfunction funcionSobrecarga(param) {\n    // hacer cosas\n    return \"\";\n}\nfuncionSobrecarga(12); // esto no da error\nfuncionSobrecarga(\"12\"); // esto no da error\n// Implementación de la función\nfunction funcionSobrecargaDiffParam(a, b) {\n    if (typeof a === \"string\" && typeof b === \"string\") {\n        return a + b;\n    }\n    else if (typeof a === \"number\" && typeof b === \"number\") {\n        return a + b;\n    }\n    throw new Error(\"Tipos de parámetros no coinciden\");\n}\nconsole.log(funcionSobrecargaDiffParam(\"Hola, \", \"mundo\")); // \"Hola, mundo\"\nconsole.log(funcionSobrecargaDiffParam(5, 10)); // 15\n//console.log(funcionSobrecargaDiffParam(\"Hola\", 10)); //ERROR\nfuncionSobrecarga(13);\n// Implementación de la función\nfunction mostrarMensaje(mensaje, veces) {\n    if (veces === undefined) {\n        console.log(mensaje);\n    }\n    else {\n        for (let i = 0; i < veces; i++) {\n            console.log(mensaje);\n        }\n    }\n}\nmostrarMensaje(\"Hola\"); // \"Hola\"\nmostrarMensaje(\"Hola\", 3); // \"Hola\" \"Hola\" \"Hola\"\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/index.ts\"]();\n",""],"names":[],"sourceRoot":""}